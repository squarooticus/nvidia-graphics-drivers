Author: Andreas Beckmann <anbe@debian.org>
Description: backport fixes for Linux 5.2/5.3 from 418.88

--- a/common/inc/nv-linux.h
+++ b/common/inc/nv-linux.h
@@ -696,16 +696,14 @@ static inline void nv_vunmap(NvUPtr vaddr, NvU32 page_count)
 #if defined(NV_SMP_CALL_FUNCTION_PRESENT)
 #if (NV_SMP_CALL_FUNCTION_ARGUMENT_COUNT == 4)
 #define NV_SMP_CALL_FUNCTION(func, info)                     \
-    ({                                                       \
-        int __ret = smp_call_function(func, info, 1, 1);     \
-        __ret;                                               \
-     })
+    do {                                                     \
+        smp_call_function(func, info, 1, 1);                 \
+    } while(0)
 #elif (NV_SMP_CALL_FUNCTION_ARGUMENT_COUNT == 3)
 #define NV_SMP_CALL_FUNCTION(func, info)                     \
-    ({                                                       \
-        int __ret = smp_call_function(func, info, 1);        \
-        __ret;                                               \
-     })
+    do {                                                     \
+        smp_call_function(func, info, 1);                    \
+    } while(0)
 #else
 #error "NV_SMP_CALL_FUNCTION_ARGUMENT_COUNT value unrecognized!"
 #endif
@@ -714,25 +712,22 @@ static inline void nv_vunmap(NvUPtr vaddr, NvU32 page_count)
 #else
 // Non-SMP case:
 #define NV_SMP_CALL_FUNCTION(func, info)                     \
-    ({                                                       \
+    do {                                                     \
         func(info);                                          \
-        0;                                                   \
-     })
+    } while(0)
 #endif
 
 #if defined(NV_ON_EACH_CPU_PRESENT)
 #if (NV_ON_EACH_CPU_ARGUMENT_COUNT == 4)
 #define NV_ON_EACH_CPU(func, info)                     \
-    ({                                                 \
-        int __ret = on_each_cpu(func, info, 1, 1);     \
-        __ret;                                         \
-     })
+    do {                                               \
+        on_each_cpu(func, info, 1, 1);                 \
+     } while (0)
 #elif (NV_ON_EACH_CPU_ARGUMENT_COUNT == 3)
 #define NV_ON_EACH_CPU(func, info)                     \
-    ({                                                 \
-        int __ret = on_each_cpu(func, info, 1);        \
-        __ret;                                         \
-     })
+    do {                                               \
+        on_each_cpu(func, info, 1);                    \
+     } while(0)
 #else
 #error "NV_ON_EACH_CPU_ARGUMENT_COUNT value unrecognized!"
 #endif
@@ -741,10 +736,9 @@ static inline void nv_vunmap(NvUPtr vaddr, NvU32 page_count)
 #else
 // Non-SMP case:
 #define NV_ON_EACH_CPU(func, info)                     \
-    ({                                                 \
+    do {                                               \
         func(info);                                    \
-        0;                                             \
-     })
+     } while(0)
 #endif
 
 #if defined(NV_GET_NUM_PHYSPAGES_PRESENT)
--- a/nvidia-uvm/uvm8_tools.c
+++ b/nvidia-uvm/uvm8_tools.c
@@ -206,18 +206,21 @@ static bool tracker_is_counter(uvm_tools_event_tracker_t *event_tracker)
     return event_tracker != NULL && !event_tracker->is_queue;
 }
 
-static void put_user_pages(struct page **pages, NvU64 page_count)
+static void uvm_put_user_pages_dirty(struct page **pages, NvU64 page_count)
 {
     NvU64 i;
-    for (i = 0; i < page_count; i++)
+
+    for (i = 0; i < page_count; i++) {
+        set_page_dirty(pages[i]);
         put_page(pages[i]);
+    }
 }
 
 static void unmap_user_pages(struct page **pages, void *addr, NvU64 size)
 {
     size = DIV_ROUND_UP(size, PAGE_SIZE);
     vunmap((NvU8 *)addr);
-    put_user_pages(pages, size);
+    uvm_put_user_pages_dirty(pages, size);
     uvm_kvfree(pages);
 }
 
@@ -281,7 +284,7 @@ fail:
     uvm_kvfree(vmas);
 
     if (ret > 0)
-        put_user_pages(*pages, ret);
+        uvm_put_user_pages_dirty(*pages, ret);
     else if (ret < 0)
         status = errno_to_nv_status(ret);
 
--- a/nvidia/nv-pat.c
+++ b/nvidia/nv-pat.c
@@ -172,11 +172,7 @@ static int nv_enable_builtin_pat_support(void)
     NV_READ_PAT_ENTRIES(orig_pat1, orig_pat2);
     nv_printf(NV_DBG_SETUP, "saved orig pats as 0x%lx 0x%lx\n", orig_pat1, orig_pat2);
 
-    if (NV_ON_EACH_CPU(nv_setup_pat_entries, NULL) != 0)
-    {
-        NV_ON_EACH_CPU(nv_restore_pat_entries, NULL);
-        return 0;
-    }
+    NV_ON_EACH_CPU(nv_setup_pat_entries, NULL);
 
     NV_READ_PAT_ENTRIES(pat1, pat2);
     nv_printf(NV_DBG_SETUP, "changed pats to 0x%lx 0x%lx\n", pat1, pat2);
@@ -187,8 +183,7 @@ static void nv_disable_builtin_pat_support(void)
 {
     unsigned long pat1, pat2;
 
-    if (NV_ON_EACH_CPU(nv_restore_pat_entries, NULL) != 0)
-        return;
+    NV_ON_EACH_CPU(nv_restore_pat_entries, NULL);
 
     nv_pat_mode = NV_PAT_MODE_DISABLED;
 
