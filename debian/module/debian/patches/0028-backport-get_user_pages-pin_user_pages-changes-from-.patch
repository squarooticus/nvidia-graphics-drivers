From 58bf72e9d1292b28924a4271b0fc8a3bd8cc4630 Mon Sep 17 00:00:00 2001
From: Andreas Beckmann <anbe@debian.org>
Date: Sun, 6 Aug 2023 17:18:58 +0200
Subject: [PATCH 2/4] backport get_user_pages/pin_user_pages changes from
 525.53

---
 common/inc/nv-mm.h            | 160 ++++++++++++++++++----------------
 conftest.sh                   |  95 ++++++++++++++++++++
 nvidia-drm/nvidia-drm-linux.c |   9 +-
 nvidia-drm/nvidia-drm.Kbuild  |   2 +
 nvidia/nvidia.Kbuild          |   2 +
 nvidia/os-mlock.c             |  10 +--
 6 files changed, 194 insertions(+), 84 deletions(-)

diff --git a/common/inc/nv-mm.h b/common/inc/nv-mm.h
index a93079b..8e033cd 100644
--- a/common/inc/nv-mm.h
+++ b/common/inc/nv-mm.h
@@ -29,6 +29,25 @@
 typedef int vm_fault_t;
 #endif
 
+/* pin_user_pages
+ * Presence of pin_user_pages() also implies the presence of unpin-user_page().
+ * Both were added in the v5.6-rc1
+ *
+ * pin_user_pages() was added by commit eddb1c228f7951d399240
+ * ("mm/gup: introduce pin_user_pages*() and FOLL_PIN") in v5.6-rc1 (2020-01-30)
+ *
+ */
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+#if defined(NV_PIN_USER_PAGES_PRESENT)
+    #define NV_PIN_USER_PAGES pin_user_pages
+    #define NV_UNPIN_USER_PAGE unpin_user_page
+#else
+    #define NV_PIN_USER_PAGES NV_GET_USER_PAGES
+    #define NV_UNPIN_USER_PAGE put_page
+#endif // NV_PIN_USER_PAGES_PRESENT
+
 /* get_user_pages
  *
  * The 8-argument version of get_user_pages was deprecated by commit
@@ -47,51 +66,57 @@ typedef int vm_fault_t;
  *
  */
 
-#if defined(NV_GET_USER_PAGES_HAS_ARGS_WRITE_FORCE)
+#if defined(NV_GET_USER_PAGES_HAS_ARGS_FLAGS)
     #define NV_GET_USER_PAGES get_user_pages
-#elif defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE)
-    #define NV_GET_USER_PAGES(start, nr_pages, write, force, pages, vmas) \
-        get_user_pages(current, current->mm, start, nr_pages, write, force, pages, vmas)
+#elif defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_FLAGS)
+    #define NV_GET_USER_PAGES(start, nr_pages, flags, pages, vmas) \
+        get_user_pages(current, current->mm, start, nr_pages, flags, pages, vmas)
 #else
-    #include <linux/mm.h>
-    #include <linux/sched.h>
-
     static inline long NV_GET_USER_PAGES(unsigned long start,
                                          unsigned long nr_pages,
-                                         int write,
-                                         int force,
+                                         unsigned int flags,
                                          struct page **pages,
                                          struct vm_area_struct **vmas)
     {
-        unsigned int flags = 0;
+        int write = flags & FOLL_WRITE;
+        int force = flags & FOLL_FORCE;
 
-        if (write)
-            flags |= FOLL_WRITE;
-        if (force)
-            flags |= FOLL_FORCE;
-
-    #if defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_FLAGS)
-        return get_user_pages(current, current->mm, start, nr_pages, flags,
-                              pages, vmas);
+    #if defined(NV_GET_USER_PAGES_HAS_ARGS_WRITE_FORCE)
+        return get_user_pages(start, nr_pages, write, force, pages, vmas);
     #else
-        // remaining defination(NV_GET_USER_PAGES_HAS_ARGS_FLAGS)
-        return get_user_pages(start, nr_pages, flags, pages, vmas);
-    #endif
+        // NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE
+        return get_user_pages(current, current->mm, start, nr_pages, write,
+                              force, pages, vmas);
+    #endif // NV_GET_USER_PAGES_HAS_ARGS_WRITE_FORCE
     }
-#endif
+#endif // NV_GET_USER_PAGES_HAS_ARGS_FLAGS
+
+/* pin_user_pages_remote
+ *
+ * pin_user_pages_remote() was added by commit eddb1c228f7951d399240
+ * ("mm/gup: introduce pin_user_pages*() and FOLL_PIN") in v5.6 (2020-01-30)
+ *
+ * pin_user_pages_remote() removed 'tsk' parameter by commit
+ * 64019a2e467a ("mm/gup: remove task_struct pointer for  all gup code")
+ * in v5.9-rc1 (2020-08-11). *
+ *
+ */
+
+#if defined(NV_PIN_USER_PAGES_REMOTE_PRESENT)
+    #if defined (NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK)
+        #define NV_PIN_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            pin_user_pages_remote(NULL, mm, start, nr_pages, flags, pages, vmas, locked)
+    #else
+        #define NV_PIN_USER_PAGES_REMOTE pin_user_pages_remote
+    #endif // NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK
+#else
+    #define NV_PIN_USER_PAGES_REMOTE NV_GET_USER_PAGES_REMOTE
+#endif // NV_PIN_USER_PAGES_REMOTE_PRESENT
 
 /*
  * get_user_pages_remote() was added by commit 1e9877902dc7
  * ("mm/gup: Introduce get_user_pages_remote()") in v4.6 (2016-02-12).
  *
- * The very next commit cde70140fed8 ("mm/gup: Overload get_user_pages()
- * functions") deprecated the 8-argument version of get_user_pages for the
- * non-remote case (calling get_user_pages with current and current->mm).
- *
- * The guidelines are: call NV_GET_USER_PAGES_REMOTE if you need the 8-argument
- * version that uses something other than current and current->mm. Use
- * NV_GET_USER_PAGES if you are refering to current and current->mm.
- *
  * Note that get_user_pages_remote() requires the caller to hold a reference on
  * the task_struct (if non-NULL and if this API has tsk argument) and the mm_struct.
  * This will always be true when using current and current->mm. If the kernel passes
@@ -113,66 +138,55 @@ typedef int vm_fault_t;
  */
 
 #if defined(NV_GET_USER_PAGES_REMOTE_PRESENT)
-    #if defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_WRITE_FORCE)
-        #define NV_GET_USER_PAGES_REMOTE    get_user_pages_remote
+    #if defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_FLAGS_LOCKED)
+        #define NV_GET_USER_PAGES_REMOTE get_user_pages_remote
+
+    #elif defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS_LOCKED)
+        #define NV_GET_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            get_user_pages_remote(NULL, mm, start, nr_pages, flags, pages, vmas, locked)
+
+    #elif defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS)
+        #define NV_GET_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            get_user_pages_remote(NULL, mm, start, nr_pages, flags, pages, vmas)
+
     #else
-        static inline long NV_GET_USER_PAGES_REMOTE(struct task_struct *tsk,
-                                                    struct mm_struct *mm,
+        // NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_WRITE_FORCE
+        static inline long NV_GET_USER_PAGES_REMOTE(struct mm_struct *mm,
                                                     unsigned long start,
                                                     unsigned long nr_pages,
-                                                    int write,
-                                                    int force,
+                                                    unsigned int flags,
                                                     struct page **pages,
-                                                    struct vm_area_struct **vmas)
+                                                    struct vm_area_struct **vmas,
+                                                    int *locked)
         {
-            unsigned int flags = 0;
-
-            if (write)
-                flags |= FOLL_WRITE;
-            if (force)
-                flags |= FOLL_FORCE;
+            int write = flags & FOLL_WRITE;
+            int force = flags & FOLL_FORCE;
 
-        #if defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS)
-            return get_user_pages_remote(tsk, mm, start, nr_pages, flags,
+            return get_user_pages_remote(NULL, mm, start, nr_pages, write, force,
                                          pages, vmas);
-        #elif defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS_LOCKED)
-            return get_user_pages_remote(tsk, mm, start, nr_pages, flags,
-                                         pages, vmas, NULL);
-        #else
-            // remaining defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_FLAGS_LOCKED)
-            return get_user_pages_remote(mm, start, nr_pages, flags,
-                                         pages, vmas, NULL);
-        #endif
         }
-    #endif
+    #endif // NV_GET_USER_PAGES_REMOTE_HAS_ARGS_FLAGS_LOCKED
 #else
     #if defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE)
-        #define NV_GET_USER_PAGES_REMOTE    get_user_pages
-    #else
-        #include <linux/mm.h>
-        #include <linux/sched.h>
-
-        static inline long NV_GET_USER_PAGES_REMOTE(struct task_struct *tsk,
-                                                    struct mm_struct *mm,
+        static inline long NV_GET_USER_PAGES_REMOTE(struct mm_struct *mm,
                                                     unsigned long start,
                                                     unsigned long nr_pages,
-                                                    int write,
-                                                    int force,
+                                                    unsigned int flags,
                                                     struct page **pages,
-                                                    struct vm_area_struct **vmas)
+                                                    struct vm_area_struct **vmas,
+                                                    int *locked)
         {
-            unsigned int flags = 0;
+            int write = flags & FOLL_WRITE;
+            int force = flags & FOLL_FORCE;
 
-            if (write)
-                flags |= FOLL_WRITE;
-            if (force)
-                flags |= FOLL_FORCE;
-
-            return get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas);
+            return get_user_pages(NULL, mm, start, nr_pages, write, force, pages, vmas);
         }
-    #endif
-#endif
 
+    #else
+        #define NV_GET_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            get_user_pages(NULL, mm, start, nr_pages, flags, pages, vmas)
+    #endif // NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE
+#endif // NV_GET_USER_PAGES_REMOTE_PRESENT
 
 /*
  * The .virtual_address field was effectively renamed to .address, by these
diff --git a/conftest.sh b/conftest.sh
index bee077f..df45f06 100755
--- a/conftest.sh
+++ b/conftest.sh
@@ -2863,6 +2863,101 @@ compile_test() {
             fi
         ;;
 
+        pin_user_pages)
+            #
+            # Determine if the function pin_user_pages() is present.
+            # Presence of pin_user_pages() also implies the presence of
+            # unpin-user_page(). Both were added in the v5.6-rc1
+            #
+            # pin_user_pages() was added by commit eddb1c228f7951d399240
+            # ("mm/gup: introduce pin_user_pages*() and FOLL_PIN") in
+            # v5.6-rc1 (2020-01-30)
+
+            # conftest #1: check if pin_user_pages() is available
+            # return if not available.
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_pin_user_pages(void) {
+                pin_user_pages();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PIN_USER_PAGES_PRESENT" "" "functions"
+        ;;
+
+        pin_user_pages_remote)
+            # Determine if the function pin_user_pages_remote() is present
+            #
+            # pin_user_pages_remote() was added by commit eddb1c228f7951d399240
+            # ("mm/gup: introduce pin_user_pages*() and FOLL_PIN")
+            # in v5.6 (2020-01-30)
+
+            # pin_user_pages_remote() removed 'tsk' parameter by
+            # commit 64019a2e467a ("mm/gup: remove task_struct pointer for
+            # all gup code") in v5.9-rc1 (2020-08-11).
+
+            #
+            # This function sets the NV_PIN_USER_PAGES_REMOTE_* macros as per
+            # the below passing conftest's
+            #
+            set_pin_user_pages_remote_defines () {
+                if [ "$1" = "" ]; then
+                    echo "#undef NV_PIN_USER_PAGES_REMOTE_PRESENT" | append_conftest "functions"
+                else
+                    echo "#define NV_PIN_USER_PAGES_REMOTE_PRESENT" | append_conftest "functions"
+                fi
+
+                if [ "$1" = "NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK" ]; then
+                    echo "#define NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK" | append_conftest "functions"
+                else
+                    echo "#undef NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK" | append_conftest "functions"
+                fi
+            }
+
+            # conftest #1: check if pin_user_pages_remote() is available
+            # return if not available.
+            # Fall through to conftest #2 if it is present
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            void conftest_pin_user_pages_remote(void) {
+                pin_user_pages_remote();
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                set_pin_user_pages_remote_defines ""
+                rm -f conftest$$.o
+                return
+            fi
+
+            # conftest #2: Check if pin_user_pages_remote() has tsk argument
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long pin_user_pages_remote(struct task_struct *tsk,
+                                       struct mm_struct *mm,
+                                       unsigned long start,
+                                       unsigned long nr_pages,
+                                       unsigned int gup_flags,
+                                       struct page **pages,
+                                       struct vm_area_struct **vmas,
+                                       int *locked) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                set_pin_user_pages_remote_defines "NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK"
+                rm -f conftest$$.o
+            else
+                set_pin_user_pages_remote_defines "NV_PIN_USER_PAGES_REMOTE_PRESENT"
+            fi
+        ;;
+
         usleep_range)
             #
             # Determine if the function usleep_range() is present.
diff --git a/nvidia-drm/nvidia-drm-linux.c b/nvidia-drm/nvidia-drm-linux.c
index f8fcde4..79d5f5c 100644
--- a/nvidia-drm/nvidia-drm-linux.c
+++ b/nvidia-drm/nvidia-drm-linux.c
@@ -93,8 +93,6 @@ int nv_drm_lock_user_pages(unsigned long address,
 {
     struct mm_struct *mm = current->mm;
     struct page **user_pages;
-    const int write = 1;
-    const int force = 0;
     int pages_pinned;
 
     user_pages = nv_drm_calloc(pages_count, sizeof(*user_pages));
@@ -105,7 +103,7 @@ int nv_drm_lock_user_pages(unsigned long address,
 
     nv_mmap_read_lock(mm);
 
-    pages_pinned = NV_GET_USER_PAGES(address, pages_count, write, force,
+    pages_pinned = NV_PIN_USER_PAGES(address, pages_count, FOLL_WRITE,
                                      user_pages, NULL);
     nv_mmap_read_unlock(mm);
 
@@ -123,7 +121,7 @@ failed:
         int i;
 
         for (i = 0; i < pages_pinned; i++) {
-            put_page(user_pages[i]);
+           NV_UNPIN_USER_PAGE(user_pages[i]);
         }
     }
 
@@ -138,8 +136,7 @@ void nv_drm_unlock_user_pages(unsigned long  pages_count, struct page **pages)
 
     for (i = 0; i < pages_count; i++) {
         set_page_dirty_lock(pages[i]);
-
-        put_page(pages[i]);
+        NV_UNPIN_USER_PAGE(pages[i]);
     }
 
     nv_drm_free(pages);
diff --git a/nvidia-drm/nvidia-drm.Kbuild b/nvidia-drm/nvidia-drm.Kbuild
index ed74f4f..9fa711b 100644
--- a/nvidia-drm/nvidia-drm.Kbuild
+++ b/nvidia-drm/nvidia-drm.Kbuild
@@ -59,6 +59,8 @@ NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_dev_unref
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_reinit_primary_mode_group
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += get_user_pages_remote
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += get_user_pages
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += pin_user_pages_remote
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += pin_user_pages
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_gem_object_lookup
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_atomic_state_ref_counting
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_driver_has_gem_prime_res_obj
diff --git a/nvidia/nvidia.Kbuild b/nvidia/nvidia.Kbuild
index 91f1516..d57cae7 100644
--- a/nvidia/nvidia.Kbuild
+++ b/nvidia/nvidia.Kbuild
@@ -222,6 +222,8 @@ NV_CONFTEST_GENERIC_COMPILE_TESTS += nvidia_grid_build
 NV_CONFTEST_GENERIC_COMPILE_TESTS += nvidia_grid_csp_build
 NV_CONFTEST_GENERIC_COMPILE_TESTS += get_user_pages
 NV_CONFTEST_GENERIC_COMPILE_TESTS += get_user_pages_remote
+NV_CONFTEST_GENERIC_COMPILE_TESTS += pin_user_pages
+NV_CONFTEST_GENERIC_COMPILE_TESTS += pin_user_pages_remote
 NV_CONFTEST_GENERIC_COMPILE_TESTS += pm_runtime_available
 NV_CONFTEST_GENERIC_COMPILE_TESTS += vm_fault_t
 NV_CONFTEST_GENERIC_COMPILE_TESTS += pci_class_multimedia_hd_audio
diff --git a/nvidia/os-mlock.c b/nvidia/os-mlock.c
index a23995c..cb80121 100644
--- a/nvidia/os-mlock.c
+++ b/nvidia/os-mlock.c
@@ -210,7 +210,7 @@ NV_STATUS NV_API_CALL os_lock_user_pages(
     struct mm_struct *mm = current->mm;
     struct page **user_pages;
     NvU64 i, pinned;
-    NvBool write = DRF_VAL(_LOCK_USER_PAGES, _FLAGS, _WRITE, flags), force = 0;
+    unsigned int gup_flags = DRF_VAL(_LOCK_USER_PAGES, _FLAGS, _WRITE, flags) ? FOLL_WRITE : 0;
     int ret;
 
     if (!NV_MAY_SLEEP())
@@ -230,8 +230,8 @@ NV_STATUS NV_API_CALL os_lock_user_pages(
     }
 
     nv_mmap_read_lock(mm);
-    ret = NV_GET_USER_PAGES((unsigned long)address,
-                            page_count, write, force, user_pages, NULL);
+    ret = NV_PIN_USER_PAGES((unsigned long)address,
+                            page_count, gup_flags, user_pages, NULL);
     nv_mmap_read_unlock(mm);
     pinned = ret;
 
@@ -243,7 +243,7 @@ NV_STATUS NV_API_CALL os_lock_user_pages(
     else if (pinned < page_count)
     {
         for (i = 0; i < pinned; i++)
-            put_page(user_pages[i]);
+            NV_UNPIN_USER_PAGE(user_pages[i]);
         os_free_mem(user_pages);
         return NV_ERR_INVALID_ADDRESS;
     }
@@ -266,7 +266,7 @@ NV_STATUS NV_API_CALL os_unlock_user_pages(
     {
         if (write)
             set_page_dirty_lock(user_pages[i]);
-        put_page(user_pages[i]);
+        NV_UNPIN_USER_PAGE(user_pages[i]);
     }
 
     os_free_mem(user_pages);
-- 
2.20.1

