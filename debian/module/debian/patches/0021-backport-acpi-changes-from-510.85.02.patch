From 06e42830c1560d15a8c2cfa628bc85283df9e3e0 Mon Sep 17 00:00:00 2001
From: Andreas Beckmann <anbe@debian.org>
Date: Tue, 18 Oct 2022 22:32:41 +0200
Subject: [PATCH] backport acpi changes from 510.85.02

---
 common/inc/nv-linux.h |  12 --
 common/inc/nv-proto.h |   3 -
 nvidia/nv-acpi.c      | 440 ------------------------------------------
 nvidia/nv.c           |  16 --
 4 files changed, 471 deletions(-)

diff --git a/common/inc/nv-linux.h b/common/inc/nv-linux.h
index 8301299..4419883 100644
--- a/common/inc/nv-linux.h
+++ b/common/inc/nv-linux.h
@@ -1630,24 +1630,12 @@ extern struct semaphore nv_linux_devices_lock;
  * and any other baggage we want to carry along
  *
  */
-#define NV_MAXNUM_DISPLAY_DEVICES 8
-
-typedef struct
-{
-    acpi_handle dev_handle;
-    int dev_id;
-} nv_video_t;
-
 typedef struct
 {
     nvidia_stack_t *sp;
     struct acpi_device *device;
     struct acpi_handle *handle;
-
-    nv_video_t pNvVideo[NV_MAXNUM_DISPLAY_DEVICES];
-
     int notify_handler_installed;
-    int default_display_mask;
 } nv_acpi_t;
 
 #endif
diff --git a/common/inc/nv-proto.h b/common/inc/nv-proto.h
index 4bc6815..d61134e 100644
--- a/common/inc/nv-proto.h
+++ b/common/inc/nv-proto.h
@@ -13,9 +13,6 @@
 
 #include "nv-misc.h"
 
-int         nv_acpi_init                (void);
-int         nv_acpi_uninit              (void);
-
 #if !defined(NV_IRQ_HANDLER_T_PRESENT) || (NV_IRQ_HANDLER_T_ARGUMENT_COUNT == 3)
 irqreturn_t nv_gvi_kern_isr             (int, void *, struct pt_regs *);
 #else
diff --git a/nvidia/nv-acpi.c b/nvidia/nv-acpi.c
index 78949af..50ad4e9 100644
--- a/nvidia/nv-acpi.c
+++ b/nvidia/nv-acpi.c
@@ -21,15 +21,6 @@ static NV_STATUS   nv_acpi_extract_buffer  (const union acpi_object *, void *, N
 static NV_STATUS   nv_acpi_extract_package (const union acpi_object *, void *, NvU32, NvU32 *);
 static NV_STATUS   nv_acpi_extract_object  (const union acpi_object *, void *, NvU32, NvU32 *);
 
-static int         nv_acpi_add             (struct acpi_device *);
-
-#if !defined(NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT) || (NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT == 2)
-static int         nv_acpi_remove_two_args(struct acpi_device *device, int type);
-#else
-static int         nv_acpi_remove_one_arg(struct acpi_device *device);
-#endif
-
-static void        nv_acpi_event           (acpi_handle, u32, void *);
 static acpi_status nv_acpi_find_methods    (acpi_handle, u32, void *, void **);
 static NV_STATUS   nv_acpi_nvif_method     (NvU32, NvU32, void *, NvU16, NvU32 *, void *, NvU16 *);
 
@@ -37,38 +28,11 @@ static NV_STATUS   nv_acpi_wmmx_method     (NvU32, NvU8 *, NvU16 *);
 static NV_STATUS   nv_acpi_mxmi_method     (NvU8 *, NvU16 *);
 static NV_STATUS   nv_acpi_mxms_method     (NvU8 *, NvU16 *);
 
-static const struct acpi_device_id nv_video_device_ids[] = {
-    { 
-        .id          = ACPI_VIDEO_HID, 
-        .driver_data = 0, 
-    },
-    { 
-        .id          = "",
-        .driver_data = 0, 
-    },
-};
-
-static struct acpi_driver *nv_acpi_driver;
 static acpi_handle nvif_handle = NULL;
-static acpi_handle nvif_parent_gpu_handle  = NULL;
 static acpi_handle wmmx_handle = NULL;
 static acpi_handle mxmi_handle = NULL;
 static acpi_handle mxms_handle = NULL;
 
-static const struct acpi_driver nv_acpi_driver_template = {
-    .name = "NVIDIA ACPI Video Driver",
-    .class = "video",
-    .ids = nv_video_device_ids,
-    .ops = {
-        .add = nv_acpi_add,
-#if !defined(NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT) || (NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT == 2)
-        .remove = nv_acpi_remove_two_args,
-#else
-        .remove = nv_acpi_remove_one_arg,
-#endif
-    },
-};
-
 static int nv_acpi_get_device_handle(nv_state_t *nv, acpi_handle *dev_handle)
 {
     nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
@@ -114,352 +78,6 @@ struct notifier_block acpi_nb = {
 };
 #endif
 
-int nv_acpi_init(void)
-{
-    /*
-     * This function will register the RM with the Linux
-     * ACPI subsystem.
-     */
-    int status;
-    nvidia_stack_t *sp = NULL;
-    NvU32 acpi_event_config = 0;
-    NV_STATUS rmStatus;
-
-    status = nv_kmem_cache_alloc_stack(&sp);
-    if (status != 0)
-    {
-        return status;
-    }
-
-    rmStatus = rm_read_registry_dword(sp, NULL, "NVreg",
-                   NV_REG_REGISTER_FOR_ACPI_EVENTS, &acpi_event_config);
-    nv_kmem_cache_free_stack(sp);
-
-    if ((rmStatus == NV_OK) && (acpi_event_config == 0))
-        return 0;
-
-    if (nv_acpi_driver != NULL)
-        return -EBUSY;
-
-    rmStatus = os_alloc_mem((void **)&nv_acpi_driver,
-            sizeof(struct acpi_driver));
-    if (rmStatus != NV_OK)
-        return -ENOMEM;
-
-    memcpy((void *)nv_acpi_driver, (void *)&nv_acpi_driver_template,
-            sizeof(struct acpi_driver));
-
-    status = acpi_bus_register_driver(nv_acpi_driver);
-    if (status < 0)
-    {
-        nv_printf(NV_DBG_INFO,
-            "NVRM: nv_acpi_init: acpi_bus_register_driver() failed (%d)!\n", status);
-        os_free_mem(nv_acpi_driver);
-        nv_acpi_driver = NULL;
-    }
-
-#if defined(NV_REGISTER_ACPI_NOTIFER_PRESENT)
-    register_acpi_notifier(&acpi_nb);
-#endif
-
-    return status;
-}
-
-int nv_acpi_uninit(void)
-{
-    nvidia_stack_t *sp = NULL;
-    NvU32 acpi_event_config = 0;
-    NV_STATUS rmStatus;
-    int rc;
-
-#if defined(NV_REGISTER_ACPI_NOTIFER_PRESENT)
-    unregister_acpi_notifier(&acpi_nb);
-#endif
-
-    rc = nv_kmem_cache_alloc_stack(&sp);
-    if (rc != 0)
-    {
-        return rc;
-    }
-
-    rmStatus = rm_read_registry_dword(sp, NULL, "NVreg",
-                   NV_REG_REGISTER_FOR_ACPI_EVENTS, &acpi_event_config);
-    nv_kmem_cache_free_stack(sp);
-  
-    if ((rmStatus == NV_OK) && (acpi_event_config == 0))
-        return 0;
-
-    if (nv_acpi_driver == NULL)
-        return -ENXIO;
-
-    acpi_bus_unregister_driver(nv_acpi_driver);
-    os_free_mem(nv_acpi_driver);
-
-    nv_acpi_driver = NULL;
-
-    return 0;
-}
-
-static int nv_acpi_add(struct acpi_device *device)
-{
-    /*
-     * This function will cause RM to initialize the things it needs for acpi interaction
-     * on the display device.
-     */
-    int status = -1;
-    NV_STATUS rmStatus = NV_ERR_GENERIC;
-    nv_acpi_t *pNvAcpiObject = NULL;
-    union acpi_object control_argument_0 = { ACPI_TYPE_INTEGER };
-    struct acpi_object_list control_argument_list = { 0, NULL };
-    nvidia_stack_t *sp = NULL;
-    struct list_head *node, *next;
-    unsigned long long device_id = 0;
-    int device_counter = 0;
-
-    status = nv_kmem_cache_alloc_stack(&sp);
-    if (status != 0)
-    {
-        return status;
-    }
-
-    // allocate data structure we need
-    rmStatus = os_alloc_mem((void **) &pNvAcpiObject, sizeof(nv_acpi_t));
-    if (rmStatus != NV_OK)
-    {
-        nv_kmem_cache_free_stack(sp);
-        nv_printf(NV_DBG_ERRORS,
-            "NVRM: nv_acpi_add: failed to allocate ACPI device management data!\n");
-        return -ENOMEM;
-    }
-
-    os_mem_set((void *)pNvAcpiObject, 0, sizeof(nv_acpi_t));
-
-    device->driver_data = pNvAcpiObject;
-    pNvAcpiObject->device = device;
-
-    pNvAcpiObject->sp = sp;
-
-    // grab handles to all the important nodes representing devices
-
-    list_for_each_safe(node, next, &device->children) 
-    {
-        struct acpi_device *dev =
-            list_entry(node, struct acpi_device, node);
-
-        if (!dev)
-            continue;
-
-        if (device_counter == NV_MAXNUM_DISPLAY_DEVICES)
-        {
-            nv_printf(NV_DBG_ERRORS, 
-                      "NVRM: nv_acpi_add: Total number of devices cannot exceed %d\n", 
-                      NV_MAXNUM_DISPLAY_DEVICES);
-            break;
-        }
-
-        status =
-            acpi_evaluate_integer(dev->handle, "_ADR", NULL, &device_id);
-        if (ACPI_FAILURE(status))
-            /* Couldnt query device_id for this device */
-            continue;
-
-        device_id = (device_id & 0xffff);
-
-        if ((device_id != 0x100) && /* Not a known CRT device-id */ 
-            (device_id != 0x200) && /* Not a known TV device-id */ 
-            (device_id != 0x0110) && (device_id != 0x0118) && (device_id != 0x0400) && /* Not an LCD*/
-            (device_id != 0x0111) && (device_id != 0x0120) && (device_id != 0x0300)) /* Not a known DVI device-id */ 
-        {
-            /* This isnt a known device Id. 
-               Do default switching on this system. */
-            pNvAcpiObject->default_display_mask = 1;
-            break;
-        }
-
-        pNvAcpiObject->pNvVideo[device_counter].dev_id = device_id;
-        pNvAcpiObject->pNvVideo[device_counter].dev_handle = dev->handle;
-    
-        device_counter++;
-
-    }
-
-    // arg 0, bits 1:0, 0 = enable events
-    control_argument_0.integer.type = ACPI_TYPE_INTEGER;
-    control_argument_0.integer.value = 0x0;
-
-    // listify it
-    control_argument_list.count = 1;
-    control_argument_list.pointer = &control_argument_0;
-
-    // _DOS method takes 1 argument and returns nothing
-    status = acpi_evaluate_object(device->handle, "_DOS", &control_argument_list, NULL);
-
-    if (ACPI_FAILURE(status))
-    {
-        nv_printf(NV_DBG_INFO,
-            "NVRM: nv_acpi_add: failed to enable display switch events (%d)!\n", status);
-    }
-
-    status = acpi_install_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,
-                    nv_acpi_event, pNvAcpiObject);
-
-    if (ACPI_FAILURE(status))
-    {
-        nv_printf(NV_DBG_INFO,
-            "NVRM: nv_acpi_add: failed to install event notification handler (%d)!\n", status);
-    }
-    else
-    {
-        try_module_get(THIS_MODULE);
-        pNvAcpiObject->notify_handler_installed = 1;
-    }
-
-    return 0;
-}
-
-#if !defined(NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT) || (NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT == 2)
-static int nv_acpi_remove_two_args(struct acpi_device *device, int type)
-#else
-static int nv_acpi_remove_one_arg(struct acpi_device *device)
-#endif
-{
-    /*
-     * This function will cause RM to relinquish control of the VGA ACPI device.
-     */
-    acpi_status status;
-    union acpi_object control_argument_0 = { ACPI_TYPE_INTEGER };
-    struct acpi_object_list control_argument_list = { 0, NULL };
-    nv_acpi_t *pNvAcpiObject = device->driver_data;
-
-
-    pNvAcpiObject->default_display_mask = 0;
-
-    // arg 0, bits 1:0, 1 = disable events
-    control_argument_0.integer.type = ACPI_TYPE_INTEGER;
-    control_argument_0.integer.value = 0x1;
-
-    // listify it
-    control_argument_list.count = 1;
-    control_argument_list.pointer = &control_argument_0;
-
-    // _DOS method takes 1 argument and returns nothing
-    status = acpi_evaluate_object(device->handle, "_DOS", &control_argument_list, NULL);
-
-    if (ACPI_FAILURE(status))
-    {
-        nv_printf(NV_DBG_INFO,
-            "NVRM: nv_acpi_remove: failed to disable display switch events (%d)!\n", status);
-    }
-
-    if (pNvAcpiObject->notify_handler_installed)
-    {
-        // remove event notifier
-        status = acpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY, nv_acpi_event);
-    }
-
-    if (pNvAcpiObject->notify_handler_installed &&
-        ACPI_FAILURE(status))
-    {
-        nv_printf(NV_DBG_INFO,
-            "NVRM: nv_acpi_remove: failed to remove event notification handler (%d)!\n", status);
-    }
-    else
-    {
-        nv_kmem_cache_free_stack(pNvAcpiObject->sp);
-        os_free_mem((void *)pNvAcpiObject);
-        module_put(THIS_MODULE);
-        device->driver_data = NULL;
-    }
-
-    return status;
-}
-
-static void nv_acpi_event(acpi_handle handle, u32 event_type, void *data)
-{
-    /*
-     * This function will handle acpi events from the linux kernel, used
-     * to detect notifications from the VGA device.
-     */
-    nv_acpi_t *pNvAcpiObject = data;
-    u32 event_val = 0;
-    unsigned long long state;
-    int status = 0;
-    int device_counter = 0;
-
-    if (event_type == NVIF_DISPLAY_DEVICE_CHANGE_EVENT)
-    {
-        /* We are getting NVIF events on this machine. We arent putting a very
-           extensive handling in-place to communicate back with SBIOS, know 
-           the next enabled devices, and then do the switch. We just 
-           pass a default display switch event, so that X-driver decides 
-           the switching policy itself. */
-        rm_system_event(pNvAcpiObject->sp, NV_SYSTEM_ACPI_DISPLAY_SWITCH_EVENT, 0);
-    }
-    if (event_type == ACPI_DISPLAY_DEVICE_CHANGE_EVENT)
-    {
-        if (pNvAcpiObject->default_display_mask != 1) 
-        {
-            while ((device_counter < NV_MAXNUM_DISPLAY_DEVICES) && 
-                   (pNvAcpiObject->pNvVideo[device_counter].dev_handle))
-            {
-                acpi_handle dev_handle = pNvAcpiObject->pNvVideo[device_counter].dev_handle;
-                int dev_id = pNvAcpiObject->pNvVideo[device_counter].dev_id;
-    
-                status = acpi_evaluate_integer(dev_handle,
-                                               "_DGS", 
-                                               NULL, 
-                                               &state);
-                if (ACPI_FAILURE(status)) 
-                {
-                    nv_printf(NV_DBG_INFO, 
-                    "NVRM: nv_acpi_event: failed to query _DGS method for display device 0x%x\n",
-                    dev_id);
-                }
-                else if (state)
-                {
-                    /* Check if the device is a CRT ...*/
-                    if (dev_id == 0x0100)
-                    {
-                        event_val |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT;
-                    }
-                    /* device-id for a TV */
-                    else if (dev_id == 0x0200)
-                    {
-                        event_val |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV;
-                    }
-                    else if ((dev_id == 0x0110) ||  /* device id for internal LCD */
-                             (dev_id == 0x0118) ||  /* alternate ACPI ID for the
-                                                                        internal LCD */
-                             (dev_id == 0x0400))    /* ACPI spec 3.0 specified
-                                                 device id for a internal LCD*/
-                    {
-                        event_val |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD;
-                    }
-                    else if ((dev_id == 0x0111) || /* the set
-                                                    of possible device-ids for a DFP */
-                             (dev_id == 0x0120) ||
-                             (dev_id == 0x0300))   /* ACPI spec 3.0 specified
-                                                    device id for non-LVDS DFP */
-                    {
-                        event_val |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP;
-                    }
-                }
-                device_counter++;
-            }
-        }
-
-        nv_printf(NV_DBG_INFO,
-        "NVRM: nv_acpi_event: Event-type 0x%x, Event-val 0x%x\n", 
-        event_type, event_val);
-
-        rm_system_event(pNvAcpiObject->sp, NV_SYSTEM_ACPI_DISPLAY_SWITCH_EVENT, event_val);
-    }
-
-    // no unsubscription or re-enable necessary. Once DOD has been set, we are go.
-    // once we are subscribed to ACPI events, we don't have to re-subscribe unless
-    // unsubscribe.
-}
-
 /* Do the necessary allocations and install notifier "handler" on the device-node "device" */
 static nv_acpi_t* nv_install_notifier(struct acpi_handle *handle, acpi_notify_handler handler)
 {
@@ -533,11 +151,6 @@ static void nv_uninstall_notifier(nv_acpi_t *pNvAcpiObject, acpi_notify_handler
 
 void NV_API_CALL nv_acpi_methods_init(NvU32 *handlesPresent)
 {
-#if defined(NV_ACPI_BUS_GET_DEVICE_PRESENT)
-    struct acpi_device *device = NULL;
-    int retVal = -1;
-#endif
-
     if (!handlesPresent) // Caller passed us invalid pointer.
         return;
 
@@ -549,32 +162,6 @@ void NV_API_CALL nv_acpi_methods_init(NvU32 *handlesPresent)
     if (nvif_handle)
     {
         *handlesPresent = NV_ACPI_NVIF_HANDLE_PRESENT;
-#if defined(NV_ACPI_BUS_GET_DEVICE_PRESENT)
-        do
-        {
-            if (!nvif_parent_gpu_handle) /* unknown error */
-                break;
-            
-            retVal = acpi_bus_get_device(nvif_parent_gpu_handle, &device);
-
-            if (ACPI_FAILURE(retVal) || !device)
-                break;
-
-            if (device->driver_data)
-            {
-                nvif_parent_gpu_handle = NULL;
-                break;  /* Someone else has already populated this device 
-                           nodes' structures. So nothing more to be done */
-            }
-
-            device->driver_data  = nv_install_notifier(device->handle, nv_acpi_event);
-
-
-            if (!device->driver_data)
-                nvif_parent_gpu_handle = NULL;
-
-        } while (0);
-#endif
     }
 
     if (wmmx_handle)
@@ -599,7 +186,6 @@ acpi_status nv_acpi_find_methods(
     if (!acpi_get_handle(handle, "NVIF", &method_handle))
     {
         nvif_handle = method_handle;
-        nvif_parent_gpu_handle = handle;
     }
 
     if (!acpi_get_handle(handle, "WMMX", &method_handle))
@@ -622,26 +208,10 @@ acpi_status nv_acpi_find_methods(
 
 void NV_API_CALL nv_acpi_methods_uninit(void)
 {
-    struct acpi_device *device = NULL;
-
     nvif_handle = NULL;
     wmmx_handle = NULL;
     mxmi_handle = NULL;
     mxms_handle = NULL;
-
-    if (nvif_parent_gpu_handle == NULL) 
-        return;
-
-#if defined(NV_ACPI_BUS_GET_DEVICE_PRESENT)
-    acpi_bus_get_device(nvif_parent_gpu_handle, &device);
-
-    nv_uninstall_notifier(device->driver_data, nv_acpi_event);
-#endif
-
-    device->driver_data = NULL;
-    nvif_parent_gpu_handle = NULL;
-
-    return;
 }
 
 static NV_STATUS nv_acpi_extract_integer(
@@ -1519,16 +1089,6 @@ static NV_STATUS  nv_acpi_wmmx_method(
 
 #else // NV_LINUX_ACPI_EVENTS_SUPPORTED
 
-int nv_acpi_init(void)
-{
-    return 0;
-}
-
-int nv_acpi_uninit(void)
-{
-    return 0;
-}
-
 void NV_API_CALL nv_acpi_methods_init(NvU32 *handlePresent)
 {
     *handlePresent = 0;
diff --git a/nvidia/nv.c b/nvidia/nv.c
index 8fd90b6..a618635 100644
--- a/nvidia/nv.c
+++ b/nvidia/nv.c
@@ -2608,7 +2608,6 @@ nvidia_ctl_open(
     nv_linux_state_t *nvl = &nv_ctl_device;
     nv_state_t *nv = NV_STATE_PTR(nvl);
     nv_file_private_t *nvfp = NV_GET_FILE_PRIVATE(file);
-    static int count = 0;
 
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_ctl_open\n");
 
@@ -2622,13 +2621,6 @@ nvidia_ctl_open(
         init_waitqueue_head(&nv_ctl_waitqueue);
 
         nv->flags |= (NV_FLAG_OPEN | NV_FLAG_CONTROL);
-
-        if ((nv_acpi_init() < 0) &&
-            (count++ < NV_MAX_RECURRING_WARNING_MESSAGES))
-        {
-            nv_printf(NV_DBG_ERRORS,
-                "NVRM: failed to register with the ACPI subsystem!\n");
-        }
     }
 
     NV_ATOMIC_INC(nvl->usage_count);
@@ -2652,7 +2644,6 @@ nvidia_ctl_close(
     nv_state_t *nv = NV_STATE_PTR(nvl);
     nv_file_private_t *nvfp = NV_GET_FILE_PRIVATE(file);
     nvidia_stack_t *sp = nvfp->sp;
-    static int count = 0;
     unsigned int i;
 
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_ctl_close\n");
@@ -2669,13 +2660,6 @@ nvidia_ctl_close(
     if (NV_ATOMIC_DEC_AND_TEST(nvl->usage_count))
     {
         nv->flags &= ~NV_FLAG_OPEN;
-
-        if ((nv_acpi_uninit() < 0) &&
-            (count++ < NV_MAX_RECURRING_WARNING_MESSAGES))
-        {
-            nv_printf(NV_DBG_ERRORS,
-                "NVRM: failed to unregister from the ACPI subsystem!\n");
-        }
     }
     up(&nvl->ldata_lock);
 
-- 
2.20.1

