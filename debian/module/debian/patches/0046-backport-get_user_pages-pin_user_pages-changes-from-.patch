From 0fcd5e6fa617fbacffa82a37fd55ce4d6ea25f1b Mon Sep 17 00:00:00 2001
From: Andreas Beckmann <anbe@debian.org>
Date: Sun, 6 Aug 2023 17:18:58 +0200
Subject: [PATCH 3/4] backport get_user_pages/pin_user_pages changes from
 525.53

---
 Makefile    |   2 +
 conftest.sh |  95 +++++++++++++++++++++++++++++++
 nv-linux.h  | 159 ++++++++++++++++++++++++++++------------------------
 os-mlock.c  |  10 ++--
 4 files changed, 189 insertions(+), 77 deletions(-)

diff --git a/Makefile b/Makefile
index a17d609..6707dac 100644
--- a/Makefile
+++ b/Makefile
@@ -143,6 +143,8 @@ COMPILE_TESTS = \
 	node_end_pfn \
 	get_user_pages \
 	get_user_pages_remote \
+	pin_user_pages \
+	pin_user_pages_remote \
 	register_cpu_notifier \
 	cpuhp_setup_state \
 	vm_fault_present \
diff --git a/conftest.sh b/conftest.sh
index 4d7fe13..6227ffd 100755
--- a/conftest.sh
+++ b/conftest.sh
@@ -2171,6 +2171,101 @@ compile_test() {
             fi
         ;;
 
+        pin_user_pages)
+            #
+            # Determine if the function pin_user_pages() is present.
+            # Presence of pin_user_pages() also implies the presence of
+            # unpin-user_page(). Both were added in the v5.6-rc1
+            #
+            # pin_user_pages() was added by commit eddb1c228f7951d399240
+            # ("mm/gup: introduce pin_user_pages*() and FOLL_PIN") in
+            # v5.6-rc1 (2020-01-30)
+
+            # conftest #1: check if pin_user_pages() is available
+            # return if not available.
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_pin_user_pages(void) {
+                pin_user_pages();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PIN_USER_PAGES_PRESENT" "" "functions"
+        ;;
+
+        pin_user_pages_remote)
+            # Determine if the function pin_user_pages_remote() is present
+            #
+            # pin_user_pages_remote() was added by commit eddb1c228f7951d399240
+            # ("mm/gup: introduce pin_user_pages*() and FOLL_PIN")
+            # in v5.6 (2020-01-30)
+
+            # pin_user_pages_remote() removed 'tsk' parameter by
+            # commit 64019a2e467a ("mm/gup: remove task_struct pointer for
+            # all gup code") in v5.9-rc1 (2020-08-11).
+
+            #
+            # This function sets the NV_PIN_USER_PAGES_REMOTE_* macros as per
+            # the below passing conftest's
+            #
+            set_pin_user_pages_remote_defines () {
+                if [ "$1" = "" ]; then
+                    echo "#undef NV_PIN_USER_PAGES_REMOTE_PRESENT" | append_conftest "functions"
+                else
+                    echo "#define NV_PIN_USER_PAGES_REMOTE_PRESENT" | append_conftest "functions"
+                fi
+
+                if [ "$1" = "NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK" ]; then
+                    echo "#define NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK" | append_conftest "functions"
+                else
+                    echo "#undef NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK" | append_conftest "functions"
+                fi
+            }
+
+            # conftest #1: check if pin_user_pages_remote() is available
+            # return if not available.
+            # Fall through to conftest #2 if it is present
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            void conftest_pin_user_pages_remote(void) {
+                pin_user_pages_remote();
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                set_pin_user_pages_remote_defines ""
+                rm -f conftest$$.o
+                return
+            fi
+
+            # conftest #2: Check if pin_user_pages_remote() has tsk argument
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long pin_user_pages_remote(struct task_struct *tsk,
+                                       struct mm_struct *mm,
+                                       unsigned long start,
+                                       unsigned long nr_pages,
+                                       unsigned int gup_flags,
+                                       struct page **pages,
+                                       struct vm_area_struct **vmas,
+                                       int *locked) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                set_pin_user_pages_remote_defines "NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK"
+                rm -f conftest$$.o
+            else
+                set_pin_user_pages_remote_defines "NV_PIN_USER_PAGES_REMOTE_PRESENT"
+            fi
+        ;;
+
         drm_driver_unload_has_int_return_type)
             #
             # Determine if drm_driver::unload() returns integer value, which has
diff --git a/nv-linux.h b/nv-linux.h
index 2aa2e77..4c62962 100644
--- a/nv-linux.h
+++ b/nv-linux.h
@@ -2108,6 +2108,25 @@ static inline NvU64 nv_node_end_pfn(int nid)
 #define mmap_sem mmap_lock
 #endif
 
+/* pin_user_pages
+ * Presence of pin_user_pages() also implies the presence of unpin-user_page().
+ * Both were added in the v5.6-rc1
+ *
+ * pin_user_pages() was added by commit eddb1c228f7951d399240
+ * ("mm/gup: introduce pin_user_pages*() and FOLL_PIN") in v5.6-rc1 (2020-01-30)
+ *
+ */
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+#if defined(NV_PIN_USER_PAGES_PRESENT)
+    #define NV_PIN_USER_PAGES pin_user_pages
+    #define NV_UNPIN_USER_PAGE unpin_user_page
+#else
+    #define NV_PIN_USER_PAGES NV_GET_USER_PAGES
+    #define NV_UNPIN_USER_PAGE put_page
+#endif // NV_PIN_USER_PAGES_PRESENT
+
 /* get_user_pages
  *
  * The 8-argument version of get_user_pages was deprecated by commit 
@@ -2126,51 +2145,57 @@ static inline NvU64 nv_node_end_pfn(int nid)
  *
  */
 
-#if defined(NV_GET_USER_PAGES_HAS_ARGS_WRITE_FORCE)
+#if defined(NV_GET_USER_PAGES_HAS_ARGS_FLAGS)
     #define NV_GET_USER_PAGES get_user_pages
-#elif defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE)
-    #define NV_GET_USER_PAGES(start, nr_pages, write, force, pages, vmas) \
-        get_user_pages(current, current->mm, start, nr_pages, write, force, pages, vmas)
+#elif defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_FLAGS)
+    #define NV_GET_USER_PAGES(start, nr_pages, flags, pages, vmas) \
+        get_user_pages(current, current->mm, start, nr_pages, flags, pages, vmas)
 #else
-    #include <linux/mm.h>
-    #include <linux/sched.h>
-
     static inline long NV_GET_USER_PAGES(unsigned long start,
                                          unsigned long nr_pages,
-                                         int write,
-                                         int force,
+                                         unsigned int flags,
                                          struct page **pages,
                                          struct vm_area_struct **vmas)
     {
-        unsigned int flags = 0;
+        int write = flags & FOLL_WRITE;
+        int force = flags & FOLL_FORCE;
 
-        if (write)
-            flags |= FOLL_WRITE;
-        if (force)
-            flags |= FOLL_FORCE;
-
-    #if defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_FLAGS)
-        return get_user_pages(current, current->mm, start, nr_pages, flags,
-                              pages, vmas);
+    #if defined(NV_GET_USER_PAGES_HAS_ARGS_WRITE_FORCE)
+        return get_user_pages(start, nr_pages, write, force, pages, vmas);
     #else
-        // remaining defination(NV_GET_USER_PAGES_HAS_ARGS_FLAGS)
-        return get_user_pages(start, nr_pages, flags, pages, vmas);
-    #endif
+        // NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE
+        return get_user_pages(current, current->mm, start, nr_pages, write,
+                              force, pages, vmas);
+    #endif // NV_GET_USER_PAGES_HAS_ARGS_WRITE_FORCE
     }
-#endif
+#endif // NV_GET_USER_PAGES_HAS_ARGS_FLAGS
+
+/* pin_user_pages_remote
+ *
+ * pin_user_pages_remote() was added by commit eddb1c228f7951d399240
+ * ("mm/gup: introduce pin_user_pages*() and FOLL_PIN") in v5.6 (2020-01-30)
+ *
+ * pin_user_pages_remote() removed 'tsk' parameter by commit
+ * 64019a2e467a ("mm/gup: remove task_struct pointer for  all gup code")
+ * in v5.9-rc1 (2020-08-11). *
+ *
+ */
+
+#if defined(NV_PIN_USER_PAGES_REMOTE_PRESENT)
+    #if defined (NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK)
+        #define NV_PIN_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            pin_user_pages_remote(NULL, mm, start, nr_pages, flags, pages, vmas, locked)
+    #else
+        #define NV_PIN_USER_PAGES_REMOTE pin_user_pages_remote
+    #endif // NV_PIN_USER_PAGES_REMOTE_HAS_ARGS_TSK
+#else
+    #define NV_PIN_USER_PAGES_REMOTE NV_GET_USER_PAGES_REMOTE
+#endif // NV_PIN_USER_PAGES_REMOTE_PRESENT
 
 /*
  * get_user_pages_remote() was added by commit 1e9877902dc7
  * ("mm/gup: Introduce get_user_pages_remote()") in v4.6 (2016-02-12).
  *
- * The very next commit cde70140fed8 ("mm/gup: Overload get_user_pages()
- * functions") deprecated the 8-argument version of get_user_pages for the
- * non-remote case (calling get_user_pages with current and current->mm).
- *
- * The guidelines are: call NV_GET_USER_PAGES_REMOTE if you need the 8-argument
- * version that uses something other than current and current->mm. Use
- * NV_GET_USER_PAGES if you are refering to current and current->mm.
- *
  * Note that get_user_pages_remote() requires the caller to hold a reference on
  * the task_struct (if non-NULL and if this API has tsk argument) and the mm_struct.
  * This will always be true when using current and current->mm. If the kernel passes
@@ -2192,65 +2217,55 @@ static inline NvU64 nv_node_end_pfn(int nid)
  */
 
 #if defined(NV_GET_USER_PAGES_REMOTE_PRESENT)
-    #if defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_WRITE_FORCE)
+    #if defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_FLAGS_LOCKED)
         #define NV_GET_USER_PAGES_REMOTE get_user_pages_remote
+
+    #elif defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS_LOCKED)
+        #define NV_GET_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            get_user_pages_remote(NULL, mm, start, nr_pages, flags, pages, vmas, locked)
+
+    #elif defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS)
+        #define NV_GET_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            get_user_pages_remote(NULL, mm, start, nr_pages, flags, pages, vmas)
+
     #else
-        static inline long NV_GET_USER_PAGES_REMOTE(struct task_struct *tsk,
-                                                    struct mm_struct *mm,
+        // NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_WRITE_FORCE
+        static inline long NV_GET_USER_PAGES_REMOTE(struct mm_struct *mm,
                                                     unsigned long start,
                                                     unsigned long nr_pages,
-                                                    int write,
-                                                    int force,
+                                                    unsigned int flags,
                                                     struct page **pages,
-                                                    struct vm_area_struct **vmas)
+                                                    struct vm_area_struct **vmas,
+                                                    int *locked)
         {
-            unsigned int flags = 0;
-
-            if (write)
-                flags |= FOLL_WRITE;
-            if (force)
-                flags |= FOLL_FORCE;
+            int write = flags & FOLL_WRITE;
+            int force = flags & FOLL_FORCE;
 
-        #if defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS)
-            return get_user_pages_remote(tsk, mm, start, nr_pages, flags,
+            return get_user_pages_remote(NULL, mm, start, nr_pages, write, force,
                                          pages, vmas);
-        #elif defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_TSK_FLAGS_LOCKED)
-            return get_user_pages_remote(tsk, mm, start, nr_pages, flags,
-                                         pages, vmas, NULL);
-        #else
-            // remaining defined(NV_GET_USER_PAGES_REMOTE_HAS_ARGS_FLAGS_LOCKED)
-            return get_user_pages_remote(mm, start, nr_pages, flags,
-                                         pages, vmas, NULL);
-        #endif
         }
-    #endif
+    #endif // NV_GET_USER_PAGES_REMOTE_HAS_ARGS_FLAGS_LOCKED
 #else
     #if defined(NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE)
-        #define NV_GET_USER_PAGES_REMOTE    get_user_pages
-    #else
-        #include <linux/mm.h>
-        #include <linux/sched.h>
-
-        static inline long NV_GET_USER_PAGES_REMOTE(struct task_struct *tsk,
-                                                    struct mm_struct *mm,
+        static inline long NV_GET_USER_PAGES_REMOTE(struct mm_struct *mm,
                                                     unsigned long start,
                                                     unsigned long nr_pages,
-                                                    int write,
-                                                    int force,
+                                                    unsigned int flags,
                                                     struct page **pages,
-                                                    struct vm_area_struct **vmas)
+                                                    struct vm_area_struct **vmas,
+                                                    int *locked)
         {
-            unsigned int flags = 0;
+            int write = flags & FOLL_WRITE;
+            int force = flags & FOLL_FORCE;
 
-            if (write)
-                flags |= FOLL_WRITE;
-            if (force)
-                flags |= FOLL_FORCE;
-
-            return get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas);
+            return get_user_pages(NULL, mm, start, nr_pages, write, force, pages, vmas);
         }
-    #endif
-#endif
+
+    #else
+        #define NV_GET_USER_PAGES_REMOTE(mm, start, nr_pages, flags, pages, vmas, locked) \
+            get_user_pages(NULL, mm, start, nr_pages, flags, pages, vmas)
+    #endif // NV_GET_USER_PAGES_HAS_ARGS_TSK_WRITE_FORCE
+#endif // NV_GET_USER_PAGES_REMOTE_PRESENT
 
 #if defined(NV_VM_AREA_STRUCT_HAS_CONST_VM_FLAGS)
 static inline void nv_vm_flags_set(struct vm_area_struct *vma, vm_flags_t flags)
diff --git a/os-mlock.c b/os-mlock.c
index 8a1fa2f..87d7cf6 100644
--- a/os-mlock.c
+++ b/os-mlock.c
@@ -25,7 +25,7 @@ RM_STATUS NV_API_CALL os_lock_user_pages(
     struct mm_struct *mm = current->mm;
     struct page **user_pages;
     NvU32 i, pinned;
-    NvBool write = 1, force = 0;
+    unsigned int gup_flags = 1 ? FOLL_WRITE : 0;
     int ret;
 
     if (!NV_MAY_SLEEP())
@@ -45,8 +45,8 @@ RM_STATUS NV_API_CALL os_lock_user_pages(
     }
 
     down_read(&mm->mmap_sem);
-    ret = NV_GET_USER_PAGES((unsigned long)address,
-                            page_count, write, force, user_pages, NULL);
+    ret = NV_PIN_USER_PAGES((unsigned long)address,
+                            page_count, gup_flags, user_pages, NULL);
     up_read(&mm->mmap_sem);
     pinned = ret;
 
@@ -58,7 +58,7 @@ RM_STATUS NV_API_CALL os_lock_user_pages(
     else if (pinned < page_count)
     {
         for (i = 0; i < pinned; i++)
-            put_page(user_pages[i]);
+            NV_UNPIN_USER_PAGE(user_pages[i]);
         os_free_mem(user_pages);
         return RM_ERR_INVALID_ADDRESS;
     }
@@ -85,7 +85,7 @@ RM_STATUS NV_API_CALL os_unlock_user_pages(
     {
         if (write)
             set_page_dirty_lock(user_pages[i]);
-        put_page(user_pages[i]);
+        NV_UNPIN_USER_PAGE(user_pages[i]);
     }
 
     os_free_mem(user_pages);
-- 
2.20.1

