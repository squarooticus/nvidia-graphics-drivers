From b8512b3d377f9281ca4c2c43d31b11f8764cf449 Mon Sep 17 00:00:00 2001
From: Andreas Beckmann <anbe@debian.org>
Date: Wed, 26 Aug 2020 20:10:54 +0200
Subject: [PATCH 2/3] backport nv_mmap_* (mmap_{sem=>lock}) changes from 450.57

---
 common/inc/nv-mm.h            | 54 +++++++++++++++++++++++++++++++++++
 conftest.sh                   | 18 ++++++++++++
 nvidia-drm/nvidia-drm-linux.c |  4 +--
 nvidia-drm/nvidia-drm.Kbuild  |  1 +
 nvidia/nv-mmap.c              |  2 +-
 nvidia/nvidia.Kbuild          |  1 +
 nvidia/os-mlock.c             |  8 +++---
 7 files changed, 81 insertions(+), 7 deletions(-)

diff --git a/common/inc/nv-mm.h b/common/inc/nv-mm.h
index 4d75de0..d402715 100644
--- a/common/inc/nv-mm.h
+++ b/common/inc/nv-mm.h
@@ -201,4 +201,58 @@ static inline unsigned long nv_page_fault_va(struct vm_fault *vmf)
 #endif
 }
 
+static inline void nv_mmap_read_lock(struct mm_struct *mm)
+{
+#if defined(NV_MM_HAS_MMAP_LOCK)
+    mmap_read_lock(mm);
+#else
+    down_read(&mm->mmap_sem);
+#endif
+}
+
+static inline void nv_mmap_read_unlock(struct mm_struct *mm)
+{
+#if defined(NV_MM_HAS_MMAP_LOCK)
+    mmap_read_unlock(mm);
+#else
+    up_read(&mm->mmap_sem);
+#endif
+}
+
+static inline void nv_mmap_write_lock(struct mm_struct *mm)
+{
+#if defined(NV_MM_HAS_MMAP_LOCK)
+    mmap_write_lock(mm);
+#else
+    down_write(&mm->mmap_sem);
+#endif
+}
+
+static inline void nv_mmap_write_unlock(struct mm_struct *mm)
+{
+#if defined(NV_MM_HAS_MMAP_LOCK)
+    mmap_write_unlock(mm);
+#else
+    up_write(&mm->mmap_sem);
+#endif
+}
+
+static inline int nv_mm_rwsem_is_locked(struct mm_struct *mm)
+{
+#if defined(NV_MM_HAS_MMAP_LOCK)
+    return rwsem_is_locked(&mm->mmap_lock);
+#else
+    return rwsem_is_locked(&mm->mmap_sem);
+#endif
+}
+
+static inline struct rw_semaphore *nv_mmap_get_lock(struct mm_struct *mm)
+{
+#if defined(NV_MM_HAS_MMAP_LOCK)
+    return &mm->mmap_lock;
+#else
+    return &mm->mmap_sem;
+#endif
+}
+
 #endif // __NV_MM_H__
diff --git a/conftest.sh b/conftest.sh
index b585432..6986548 100755
--- a/conftest.sh
+++ b/conftest.sh
@@ -3665,6 +3665,24 @@ compile_test() {
 
         ;;
 
+        mm_has_mmap_lock)
+            #
+            # Determine if the 'mm_struct' structure has a 'mmap_lock' field.
+            #
+            # Kernel commit da1c55f1b272 ("mmap locking API: rename mmap_sem
+            # to mmap_lock") replaced the field 'mmap_sem' by 'mmap_lock'
+            # in v5.8-rc1 (2020-06-08).
+            CODE="
+            #include <linux/mm_types.h>
+
+            int conftest_mm_has_mmap_lock(void) {
+                return offsetof(struct mm_struct, mmap_lock);
+            }"
+
+            compile_check_conftest "$CODE" "NV_MM_HAS_MMAP_LOCK" "" "types"
+
+        ;;
+
         # When adding a new conftest entry, please use the correct format for
         # specifying the relevant upstream Linux kernel commit.
         #
diff --git a/nvidia-drm/nvidia-drm-linux.c b/nvidia-drm/nvidia-drm-linux.c
index 1d3e658..f8fcde4 100644
--- a/nvidia-drm/nvidia-drm-linux.c
+++ b/nvidia-drm/nvidia-drm-linux.c
@@ -103,11 +103,11 @@ int nv_drm_lock_user_pages(unsigned long address,
         return -ENOMEM;
     }
 
-    down_read(&mm->mmap_sem);
+    nv_mmap_read_lock(mm);
 
     pages_pinned = NV_GET_USER_PAGES(address, pages_count, write, force,
                                      user_pages, NULL);
-    up_read(&mm->mmap_sem);
+    nv_mmap_read_unlock(mm);
 
     if (pages_pinned < 0 || (unsigned)pages_pinned < pages_count) {
         goto failed;
diff --git a/nvidia-drm/nvidia-drm.Kbuild b/nvidia-drm/nvidia-drm.Kbuild
index 4d4c90e..901a783 100644
--- a/nvidia-drm/nvidia-drm.Kbuild
+++ b/nvidia-drm/nvidia-drm.Kbuild
@@ -90,3 +90,4 @@ NV_CONFTEST_TYPE_COMPILE_TESTS += drm_atomic_helper_swap_state_has_stall_arg
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_driver_prime_flag_present
 NV_CONFTEST_TYPE_COMPILE_TESTS += vm_fault_t
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_gem_object_has_resv
+NV_CONFTEST_TYPE_COMPILE_TESTS += mm_has_mmap_lock
diff --git a/nvidia/nv-mmap.c b/nvidia/nv-mmap.c
index e77d53b..9159529 100644
--- a/nvidia/nv-mmap.c
+++ b/nvidia/nv-mmap.c
@@ -225,7 +225,7 @@ static vm_fault_t nvidia_fault(
 
         /*
          * GPU wakeup cannot be completed directly in the fault handler due to the
-         * inability to take the GPU lock while mmap_sem is held.
+         * inability to take the GPU lock while mmap_lock is held.
          */
         status = rm_schedule_gpu_wakeup(nvl->sp[NV_DEV_STACK_GPU_WAKEUP], nv);
         if (status != NV_OK)
diff --git a/nvidia/nvidia.Kbuild b/nvidia/nvidia.Kbuild
index 4dd0855..cffb4f5 100644
--- a/nvidia/nvidia.Kbuild
+++ b/nvidia/nvidia.Kbuild
@@ -173,6 +173,7 @@ NV_CONFTEST_TYPE_COMPILE_TESTS += sysfs_slab_unlink
 NV_CONFTEST_TYPE_COMPILE_TESTS += proc_ops
 NV_CONFTEST_TYPE_COMPILE_TESTS += vmalloc_has_pgprot_t_arg
 NV_CONFTEST_TYPE_COMPILE_TESTS += timeval
+NV_CONFTEST_TYPE_COMPILE_TESTS += mm_has_mmap_lock
 
 NV_CONFTEST_GENERIC_COMPILE_TESTS += dom0_kernel_present
 NV_CONFTEST_GENERIC_COMPILE_TESTS += nvidia_vgpu_hyperv_available
diff --git a/nvidia/os-mlock.c b/nvidia/os-mlock.c
index 1900fa1..237e2ec 100644
--- a/nvidia/os-mlock.c
+++ b/nvidia/os-mlock.c
@@ -43,7 +43,7 @@ NV_STATUS NV_API_CALL os_lookup_user_io_memory(
         return rmStatus;
     }
 
-    down_read(&mm->mmap_sem);
+    nv_mmap_read_lock(mm);
 
     vma = find_vma(mm, (NvUPtr)address);
     if ((vma == NULL) || ((vma->vm_flags & (VM_IO | VM_PFNMAP)) == 0))
@@ -76,7 +76,7 @@ NV_STATUS NV_API_CALL os_lookup_user_io_memory(
     }
 
 done:
-    up_read(&mm->mmap_sem);
+    nv_mmap_read_unlock(mm);
 
     return rmStatus;
 }
@@ -110,10 +110,10 @@ NV_STATUS NV_API_CALL os_lock_user_pages(
         return rmStatus;
     }
 
-    down_read(&mm->mmap_sem);
+    nv_mmap_read_lock(mm);
     ret = NV_GET_USER_PAGES((unsigned long)address,
                             page_count, write, force, user_pages, NULL);
-    up_read(&mm->mmap_sem);
+    nv_mmap_read_unlock(mm);
     pinned = ret;
 
     if (ret < 0)
-- 
2.20.1

